1xx	表示HTTP请求已经接受，继续处理请求
2xx	表示HTTP请求已经处理完成
3xx	表示把请求访问的URL重定向到其他目录
4xx	表示客户端出现错误
5xx	表示服务端出现错误

301 永久移动 请求的网页已永久移动到新位置。 服务器会自动将请求者转到新位置。
302 暂时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
304 刷新过快 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 


前端可以通过设置一些参数来忽略或者重写后端服务器的缓存特性
X-Accel-Expires: 只有nginx能识别的缓存特性header，优先级Expires,Cache-Contro，可以设置此header，在nginx侧来重新定义缓存特性;
Etag和Last-Modified是捆绑生成的: 有些场景下，你希望client端的浏览器长时间缓存，而缓存服务器只短时间缓存文件，以至于当后端服务器更新后，缓存服务器会及时同步，我们就可以使用最后两个header，Last-Modified表示最后修改时间，并声明一个ETag(哈希值)，做为缓存内容的标签，具有唯一性;客户端访问请求带有If‑Modified‑Since或者If‑None‑Match header，并申明自己的客户端带有静态缓存文件,以及文件修改日期和ETag值，如果服务器端的版本和Etag值与客户端一致，则服务端会直接返回304 not modified，这个验证流程是非常快的，并且节省网络带宽；
Expires: 最原始的配置策略，即设置过期时间，但使用效率低下，目前绝大部分已经被Cache-Control（有兴趣的可以去看下http1.0和http1.1）；
Cache-Control：定义缓存资源属性是private或者是public，并且设置缓存多久后过期，本例中，属性为public，60秒过期；


cache-control会覆盖其他设置 如Expires和 Last-Modified
Last-Modified
		一个时间，由服务端返回。当客户端发起请求时，服务器会返回一个Last-Modified，这是一个时间，当客户端第二次请求时
		会发送一个 If-Modified-Since:(Last-Modified的值) 的键值对。如果服务器端的资源没有变化，
		则返回304，内容为空。
	

	
Expires: 
		一个时间，由服务端返回，超过这个时间则被认为是过时。需和Last-Modified结合使用。
		在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，
		才决定从服务器更新数据。

Etag
		ETag类似一个id。服务器对请求的URL标记，得到一个类似于id的ETag,并将其返回给客户端。
		客户端的查询方式为if-None-Match:(ETag的值)，若ETag没变，则返回304。分布式通常不
		使用，因为每台机子的ETag不一样。

cache-control可选值：private、no-cache、must-revalidate、 可选属性：max-age
主要影响三个操作：打开新窗口，在地址栏回车，后退

				private       no-cache   must-revalidate   max-age = time
打开新窗口		重新 	  		重新	     重新		  		超过time后重新访问	
回车				第一次访问    	每次     第一次		  		超过time前不会重复访问
后退				不会	   			重复	     不会		



HTTP响应模型(服务器收到HTTP请求之后，会有多种方法响应这个请求，下面是HTTP响应的四种模型：)
>a.单进程I/O模型
服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理；
>b.多进程I/O模型
服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求；
>c.复用I/O模型
服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行；
>d.复用多线程I/O模型
服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。

当http承载于tsl/ssl之上时，就成了https



漏洞
>a.http://www.test.com/msg.php?send=<script>alert('I am here!')</script>  嵌入脚本
>b.User-Agent: Mozilla/5.0'(select*from(select(sleep(20)))a)   在请求头加入sql语句,令数据库睡眠20秒


https的连接过程
>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
>（5）Web服务器利用自己的私钥解密出会话密钥。
>（6）Web服务器利用会话密钥加密与客户端之间的通信。


https的缺点
>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；
>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可		以控制CA根证书的情况下，中间人攻击一样可行

http切换到HTTPS
>（1）如果需要将网站从http切换到https到底该如何实现呢？
>（2）这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com
>（3）也可以同时兼容http和https

请求 处理 响应


